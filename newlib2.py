import numpy as np
import numpy.random as rnd
from numba import njit



#find the field of one spin sensed which is generated by its nearest neighbors
@njit
def near(L,spin,N1,N2,n):
    if n==0:
        return spin[N1][N2][1]+spin[N1][N2][2]+spin[N1][(N2+1)%L][2]+spin[(N1-1)%L][(N2+1)%L][1]
    elif n==1:
        return spin[N1][N2][0]+spin[N1][N2][2]+spin[(N1+1)%L][(N2-1)%L][0]+spin[(N1+1)%L][N2][2]
    elif n==2:
        return spin[N1][N2][0]+spin[N1][N2][1]+spin[N1][(N2-1)%L][0]+spin[(N1-1)%L][N2][1]


@njit
def CanoMC(L,beta,J,spin):
    T = 1./beta
    E = 0
    for n1 in range(L):
        for n2 in range(L):
            for site in range(3):
                delta =rnd.random((3,))
                z = 1-T + delta[2]*T
                x = delta[0]/np.sqrt(delta[0]**2+delta[1]**2)*np.sqrt(1-z**2)
                y = delta[1]/np.sqrt(delta[0]**2+delta[1]**2)*np.sqrt(1-z**2)
                normal = spin[n1][n2][site]
                if normal[0] != 0 or normal[1] != 0:
                    tangent1 = np.array([-normal[1], normal[0], 0], dtype=np.float64)
                else:
                    tangent1 = np.array([1, 0, 0],dtype=np.float64)
                tangent1 /= np.linalg.norm(tangent1)
                tangent2 = np.cross(normal, tangent1)
                tangent2 /= np.linalg.norm(tangent2)
                new_S = z*normal+x*tangent1+y*tangent2
                dE = J*np.dot((new_S-spin[n1][n2][site]),near(L,spin,n1,n2,site))
                if dE<0:
                    spin[n1][n2][site]=new_S
                    E += dE
                elif rnd.random()<min(1,np.exp(-beta*dE)):
                    spin[n1][n2][site]=new_S
                    E += dE
    return spin,E

# The state of spin after the flip
# former_stete is the coordinates (x,y,n) in the lattice of the choosen spins
def later_state(lattice,former_state):
    h = near(lattice.size,lattice.spins,former_state[0],former_state[1],former_state[2])  # to be decided the input of near function
    Bef_flip = lattice.spins[former_state[0]][former_state[1]][former_state[2]] # the spin before flip
    h_2 = h[0]**2 +h[1]**2 +h[2]**2
    Si_hi = Bef_flip[0]*h[0] + Bef_flip[1]*h[1] + Bef_flip[2]*h[2]
    Fec_H = np.zeros(3)
    Fec_H = 2*(h*Si_hi/h_2)

    # Aft_flip is the new state of the spin after the operation of flipping
    Aft_flip = -Bef_flip + Fec_H
    #Aft_flip = Aft_flip/np.sqrt(Aft_flip[0]**2+Aft_flip[1]**2+Aft_flip[2]**2)
    return Aft_flip

def Over_relaxation_sub(lattice,x_0, y_0, mo_x, mo_y):
    # mo_x, mo_y determine the length of sublattice
    for i in range(mo_x):
        for k in range(mo_y):
            for n in range(3):
                cho_site = np.zeros(3,dtype=int)
                cho_site[0] = x_0 + i
                cho_site[1] = y_0 + k
                cho_site[2] = n
                Aft_flip = later_state(lattice,cho_site)
                lattice.spins[cho_site[0]][cho_site[1]][cho_site[2]] = Aft_flip


def Over_relaxation(lattice):
    L = lattice.size
    x_0 = rnd.randint(1, L-2)
    y_0 = rnd.randint(1, L-2)
    # divide the lattice into 4 indipendent parts
    # for the first part
    mo_x = x_0
    mo_y = y_0
    Over_relaxation_sub(lattice, 0, 0, mo_x, mo_y)
    # for the second part
    mo_x = L - x_0-1
    mo_y = y_0
    Over_relaxation_sub(lattice, x_0+1, 0, mo_x, mo_y)
    # for the third part
    mo_x = x_0
    mo_y = L -y_0-1
    Over_relaxation_sub(lattice, 0, y_0 - 1, mo_x, mo_y)
    # for the forth part
    mo_x = L - x_0-1
    mo_y = L- y_0-1
    Over_relaxation_sub(lattice, x_0 + 1, y_0 + 1, mo_x, mo_y)



def hybrid_Monte_Carlo(kagome,num_sites,beta): 
    num_of_over_relax = 4
    spin , dE = CanoMC(kagome.size,beta,kagome.J,kagome.spins)
    kagome.spins = spin
    kagome.energy += dE
    for k in range(num_of_over_relax):
        Over_relaxation(kagome)

def measure(kagome,num_sites,beta):
    for a in range(5):
        hybrid_Monte_Carlo(kagome,num_sites,beta)
    return kagome.energy